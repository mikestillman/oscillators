newPackage(
        "Oscillators",
        Version => "0.8", 
        Date => "7 Nov 2024",
        Authors => {
            {
                Name => "John Cobb", 
                Email => "jdc0173@auburn.edu", 
                HomePage => "https://johndcobb.github.io"
                },
            {
                Name => "Hal Schenck", 
                Email => "hks0015@auburn.edu",
                HomePage => "http://webhome.auburn.edu/~hks0015"
                },
            {
                Name => "Michael E. Stillman", 
                Email => "mike@math.cornell.edu", 
                HomePage => "http://www.math.cornell.edu/People/Faculty/stillman.html"
                }
            },
        Headline => "code to analyze graph oscillators",
        DebuggingMode => false,
        AuxiliaryFiles => false,
        PackageExports => {
            "Graphs", 
            "NumericalAlgebraicGeometry"
            }
        )

export {
    "hasNoLeaf",
    "oscRing",
    "oscQuadrics",
    "oscJacobian",
    "identifyStability",
    "findRealSolutions",
    "isStableSolution",
    "getAngles",
    "getLinearlyStableSolutions",
    "showExoticSolutions",
    "allUniquePrincipalMinors",
    "vertexSpanningPolynomial",
    "standardSols",
    -- symbols
    "Symbols",
    "numOscillators",
    "Radians",
    "Stable",
    "Unstable",
    "Semistable",
    "Modulo",
    "oscSystem",
    "trig",
    }


baseDirectory = Oscillators#"source directory"
--------------------------------------------------------------------
----- CODE
--------------------------------------------------------------------

--------------------------------------------------------------------
----- Internal Helper Functions
--------------------------------------------------------------------

hasNoLeaf = method()
hasNoLeaf Graph := G -> all(vertices G, i -> degree(G,i) > 1)


--------------------------------------------------------------------
----- Creation of main objects (OscRing, oscQuadrics)
--------------------------------------------------------------------

oscRing = method(Options => {
        Symbols => (getSymbol "x", getSymbol "y"),
        CoefficientRing => QQ,
        Reduced => false
        })

oscRing(Graph, List) := Ring => opts -> (G, params) -> (
    kk := opts.CoefficientRing;
    s := opts#Symbols#1;
    c := opts#Symbols#0;
    verticesG := sort vertices G;
    vertexList := if not opts.Reduced then verticesG else drop(verticesG, 1);
    clist := for v in vertexList list c_v;
    slist := for v in vertexList list s_v;
    R := if #params > 0
      then kk[clist,slist,params]
      else kk[clist, slist];
    R.numOscillators = # verticesG;
    R.Symbols = (c,s);
    R.Graph = G;
    R.Reduced = opts.Reduced;
    R
)
oscRing(Graph) := Ring => opts -> G -> oscRing(G, {}, opts)
oscRing(ZZ) := Ring => opts -> n -> oscRing(ringOscillatorGraph(n), {}, opts)


---------------------------------------------------
-- Jacobian Constructions
--------------------------------------------------

oscJacobian = method(Options => {Reduced=>false})
oscJacobian Ideal := opts -> P -> (
    -- P is a system created with oscSystem
    -- each polynomial should be <= linear in R_i, R_(n+i), all i=0..n-1
    R := ring P;
    G := R.Graph;
    verticesG := sort vertices G;
    vertexList := if R.Reduced or opts.Reduced then drop(verticesG, 1) else verticesG;
    -- P1 := ideal drop(P_*,1);
    sine := (i) -> if member(i, vertexList) then (select(R.generators, k -> toString k == toString (R.Symbols_1)_i))_0 else 0_R;
    cosine := (i) -> if member(i, vertexList) then (select(R.generators, k -> toString k == toString (R.Symbols_0)_i))_0 else 1_R;
    if not R.?numOscillators then error "expected ring generated by 'oscRing'";
    matrix for i in vertexList list (
        first entries (sine i * diff(cosine i, gens P) - cosine i * diff(sine i, gens P))
        )
    )
oscJacobian(Graph, Ring) := opts -> (G, R) -> (
    verticesG := sort vertices G; -- or should this be R.Graph?
    vertexList := if R.Reduced or opts.Reduced then drop(verticesG, 1) else verticesG;
    if not R.?numOscillators then error "expected ring generated by 'oscRing'";
    sine := (i) -> if member(i, vertexList) then (select(R.generators, k -> toString k == toString (R.Symbols_1)_i))_0 else 0_R;
    cosine := (i) -> if member(i, vertexList) then (select(R.generators, k -> toString k == toString (R.Symbols_0)_i))_0 else 1_R;
    matrix for i in verticesG list for j in verticesG list (
        if i =!= j then (
            if member(j, neighbors(G,i)) then (
                -- entry is cos(theta_j - theta_i)
                cosine j * cosine i + sine j * sine i
            ) else 0_R
        ) else 
          - sum for j in toList neighbors(G, i) list (cosine j * cosine i + sine j * sine i)
        )
)
oscJacobian(Graph) := opts -> G -> oscJacobian(G, oscRing(G, opts), opts)

oscQuadrics = method(Options => {Reduced=>false})
oscQuadrics(Graph, Ring) := opts -> (G, R) -> (
    verticesG := sort vertices G; -- or should this be R.Graph?
    vertexList := if R.Reduced or opts.Reduced then drop(verticesG, 1) else verticesG;
    sine := (i) -> if member(i, vertexList) then (select(R.generators, k -> toString k == toString (R.Symbols_1)_i))_0 else 0_R;
    cosine := (i) -> if member(i, vertexList) then (select(R.generators, k -> toString k == toString (R.Symbols_0)_i))_0 else 1_R;
    ideal for i in verticesG list (
        N := toList neighbors(G,i);
        sum for j in N list (
            (- sine j * cosine i + sine i * cosine j)
            )
        )
    )
oscQuadrics(Graph) := opts -> G -> oscQuadrics(G, oscRing(G), opts)

-- Helper function to return the ideal on cos and sin for n variables.
trig = method(Options => {Reduced=>false})
trig Ring := opts -> (R) -> (
    if not R.?numOscillators then error "expected ring generated by 'oscRing'";
    G := R.Graph;
    verticesG := sort vertices G;
    vertexList := if R.Reduced or opts.Reduced then drop(verticesG, 1) else verticesG;
    sine := (i) -> (select(R.generators, k -> toString k == toString (R.Symbols_1)_i))_0;
    cosine := (i) -> (select(R.generators, k -> toString k == toString (R.Symbols_0)_i))_0;
    ideal for i in vertexList list (sine i)^2+(cosine i)^2-1
    )

oscSystem = method(Options => {Reduced=>false})
oscSystem(Graph, Ring) := opts -> (G, R) -> oscQuadrics(G, R, opts) + trig(R, opts)
oscSystem(Graph) := opts -> G -> oscSystem(G, oscRing(G, opts), opts) 

----------------------------------------------------------------------------------
-- Handy Constructions
----------------------------------------------------------------------------------
ringOscillatorGraph = method()
ringOscillatorGraph(ZZ,ZZ) := (n,k) -> (
    graph unique flatten for i from 0 to n-1 list (
        for j from i-k to i+k list (
            if j == i then continue;
            j1 := if j < 0 then j + n else if j >= n then j-n else j;
            sort {i,j1}
            )
        )
    )
ringOscillatorGraph(ZZ) := (n) -> ringOscillatorGraph(n,1)

vertexSpanningPolynomial = method()
vertexSpanningPolynomial(Graph, Ring) := (G,R) -> (
    cosine := (i) -> (select(R.generators, k -> toString k == toString (R.Symbols_0)_i))_0;
    verticesG := sort vertices G;
    VG := matrix for i in verticesG list for j in verticesG list (
        if i === j then (
            sum for n in toList neighbors(G,i) list cosine n
        ) else if member(j, neighbors(G,i)) then - cosine i else 0
    );
    det submatrix(VG, 1..#vertices G - 1, 1..#verticesG - 1) // cosine (verticesG)_0
)
vertexSpanningPolynomial(Graph) := G -> vertexSpanningPolynomial(G, oscRing(G))

standardSols = method(Options => {Reduced => false})
standardSols(Graph, Ring) := opts -> (G,R) -> (
    verticesG := sort vertices G;
    vertexList := if opts.Reduced or R.Reduced then drop(verticesG, 1) else verticesG;
    sine := (i) -> if member(i, vertexList) then (select(R.generators, k -> toString k == toString (R.Symbols_1)_i))_0 else 0_R;
    cosine := (i) -> if member(i, vertexList) then (select(R.generators, k -> toString k == toString (R.Symbols_0)_i))_0 else 1_R;
    minors(2, matrix for i in verticesG list {sine i, cosine i})
)
standardSols(Graph) := opts -> G -> standardSols(G, oscRing(G, opts), opts)
----------------------------------------------------------------------------------
-- Finding solutions: beware, these might give duplicates and/or miss solutions --
----------------------------------------------------------------------------------
isReal List := (L) -> all(L, p1 -> imaginaryPart p1 == 0)

findRealSolutions = method()
findRealSolutions Ideal := (I) -> (
    -- I is an ideal over the complexes, which is zero-dimensional (might be higher dimensional though...!
    sols := solveSystem I_*;
    bads := positions(sols, p -> p.cache.SolutionStatus != Regular);
    if #bads > 0 then (<< "warning: some solutions are not regular: " << bads << endl);
    coords := matrix(sols/coordinates);
    coords = clean(.00000001, coords);
    select(entries coords, p -> all(p, p1 -> imaginaryPart p1 == 0))
    )
findRealSolutions(Graph) := (G) -> (
    n := # vertices G;
    RC := oscRing(n-1,{}, CoefficientRing => CC);
    IC := trim oscSystem(G,RC);
    JC := oscJacobian(G, RC);
    pts := findRealSolutions IC;
    for p in pts list {p, sub(JC, matrix{p}), identifyStability(JC, p, Tolerance=>1e-10)}
    )

allUniquePrincipalMinors = method(Options => {Modulo=>null})
allUniquePrincipalMinors Matrix := opts -> (M) -> (
    I := if opts.?Modulo and opts.Modulo =!= null then opts.Modulo else 0_(ring M);
    S := drop(subsets numcols M, 1); -- drop the empty subset
    -- I is an ideal in a polynomial ring over e.g. QQ
    -- M is a symmetric n by n matrix over the sam ering as I.
    if ring M =!= ring I then error "expected ideal and matrix over the same ring";
    if M - transpose M != 0 then error "expected a symmetric matrix";
    M1 := M % I;
    unique for s in S list (
        (det submatrix(M1, s, s)) % I
        )
    )

identifyStability = method(Options => {Tolerance => 1e-15})
-- returns one of the symbols Stable, Unstable, Semistable
identifyStability(Matrix, List) := Symbol => opts -> (Jac,pt) -> (
    J0 := substitute(Jac, matrix{pt});
    ev := eigenvalues J0;
    identifyStability(opts, ev)
    )
identifyStability BasicList := Symbol => opts -> eigenvals -> (
    signs := for e in eigenvals list
        if abs(realPart e) < opts.Tolerance then 0 
        else if realPart e < 0 then -1 
        else 1;
    nzero := # select(signs, s -> s === 0);
    npos := # select(signs, s -> s === 1);
    nneg := # select(signs, s -> s === -1);
    assert(nzero + npos + nneg == # eigenvals);
    if npos > 0 then Unstable
    else if nzero == 1 then Stable
    else Semistable
    )
    
isStableSolution = method()
isStableSolution(Matrix, List) := (J,pt) -> (
    J0 := substitute(J, matrix{pt});
    ev := eigenvalues J0;
    all(ev, e -> realPart e < 0.0)
    )

-----------------------------
-- twisted angle points -----
-----------------------------
twisted = method()
twisted(ZZ, ZZ, Ring) := (p, n, R) -> (
    a := cos(p*pi/n);
    c := for i from 1 to n-1 list cos(1_R * i*p*2*pi/n);
    s := for i from 1 to n-1 list sin(1_R * i*p*2*pi/n);
    c | s
    )
twisted(ZZ, ZZ, ZZ) := (p, n, prec) -> twisted(p, n, RR_prec)

----------------------------------------------------------------------------
-- Useful display functions and methods to see results in terms of angles --
----------------------------------------------------------------------------

getAngles = method(Options => {Radians => true})
getAngles(ZZ,List) := opts -> (nangles, sols) -> (
    -- assume 'sols' is a list of
    -- (cos theta_1, cos theta_1, ..., cos theta_nangles, sin theta_1, ..., sin theta_nangles, ...)
    for p in sols list (
        for i from 0 to nangles-1 list (
            --a := atan2(realPart p#(i), realPart p#(i+nangles));
            a := atan2(realPart p#(i+nangles), realPart p#(i));
            b := if a < 0 then a + 2*pi else a;
            if opts.Radians then b else b * 180/pi
            )
        )
    )

getLinearlyStableSolutions = method()
getLinearlyStableSolutions Graph := G -> (
    n := # vertices G;
    RC := oscRing(n, CoefficientRing => CC, Reduced => true);
    IC := trim oscSystem(G,RC);
    JC := oscJacobian(G, RC);
    elapsedTime realsols := findRealSolutions IC;
    stablesols := for pt in realsols list (
        result := identifyStability(JC, pt, Tolerance=>1e-10);
        if result == Stable then pt else continue
        );
    stablesols
    )

showExoticSolutions = method()
showExoticSolutions Graph := G -> (
    stablesols := getLinearlyStableSolutions G;
    n := #vertices G;
    if #stablesols > 1 then (
        << "-- found extra exotic solutions for graph " << G << " --" << endl;
        << netList stablesols << endl;
        << "-- angles (in degrees), first angle is zero and omitted --" << endl;
        << netList (getAngles(n-1, stablesols, Radians=>false)) << endl;
        );
    stablesols
    )


--------------------------------------------------------------------
----- DOCUMENTATION
--------------------------------------------------------------------
beginDocumentation()

-*
doc ///
  Key
  Headline
  Usage
  Inputs
  Outputs
  Description
    Text
    Example
  Caveat
  SeeAlso
///
*-

undocumented {
  (oscRing, Graph, List),
  Symbols,
  trig,
  (trig, Ring),
  Stable,
  Semistable,
  Unstable,
  Modulo,
  Radians,
  numOscillators
}

doc ///
Key
  Oscillators
Headline
  generation and analysis of oscillator steady states for small graphs
Description
  Text
    This package supports computations with Kuramoto oscillators,
    including computations for the paper [HSS], Harrington, Schenck,
    Stillman, @arXiv("2312.16069", "Algebraic aspects of homogeneous
    Kuramoto oscillators")@.
  Text
    @SUBSECTION "Computations from the paper [HSS]"@
  Text
    @UL {
        TO "Generation of all SCT (simple, connected, 2-connected) graphs on small numbers of vertices",
        TO "Checking the codimension and irreducible decomposion of the IG ideal",
        TO "SCT graphs with exotic solutions",
        TO "Example 4.1: unique graph on 8 vertices with exotic solutions and no induced cycle of length at least 5",
        TO "Example 4.2: a K5 and pentagon glued along an edge",
        TO "Example 4.3: examples of gluing two cycles along an edge",
        TO "Example 4.4: The square within a square"
        }@
  Text
    We show a possible workflow using this package.  We use @TO "NautyGraphs::NautyGraphs"@
    to generate graphs of small size.  We use @TO "Visualize::Visualize"@ to look at these graphs.
  Example
    needsPackage "Oscillators";
    needsPackage "NautyGraphs";
    needsPackage "Visualize";
  Text
    Let's do an example: the 5-cycle.  First, we generate all SCT graphs on 5 vertices (i.e. connected, 2-connected simple graphs),
    and grab the 5-cycle.
  Example
    Gstrs = generateGraphs(5, OnlyConnected => true, MinDegree => 2);
    Gs = Gstrs/stringToGraph
    Gcycle5 = Gs_3
  Text
    We can also create the graph directly.
  Example
    Gcycle5 == graph{{0,1},{1,2},{2,3},{3,4},{4,0}}
  Text
    To visualize this graph, use the following lines.  You have to click on End session
    in the browser to get back to Macaulay2.
  Pre
    openPort "8083"
    visualize Gcycle5 -- important: click on End session in browser window before continuing
    closePort()
  Text
    We construct all of the (steady-state) solutions to the homogeneous Kuramoto system for the 5-cycle.
    This includes all solutions, not just stable solutions.
    In this example, we first construct the real solutions, and check their (linear) stability.
    Then we find all complex solutions.  In this particular example, all 30 solutions are real.
    We set the precision displayed to 3 digits.
  Example
    printingPrecision = 3
    G = Gcycle5
    R = oscRing(G, CoefficientRing => CC, Reduced => true)
    I = oscSystem(G, R);
    netList I_*
    Jac = oscJacobian(G,R)
    realsols = findRealSolutions I;
    netList realsols
    assert(# realsols == 30)
    stablesols = select(realsols, p -> Stable === identifyStability(Jac,p))
    tally realsols/(p -> identifyStability(Jac, p))
    getAngles(4, stablesols, Radians=>false)
    sols = solveSystem I_*;
    sols = sols/coordinates;
    sols = matrix sols -- every row is a solution
    sols = clean(1e-6, sols) -- set to 0 numbers very close to 0
    assert(numrows sols == 30) -- all the solutions in this example are real
    tally (entries sols)/(p -> identifyStability(Jac, p))
  Text
    For the further analysis of these ideals, see @TO "oscQuadrics"@.
///

///
Key
  Oscillators
Headline
  generation and analysis of oscillator steady states for small graphs
Description
  Text
    We show a possible workflow using this package.  We use @TO "NautyGraphs::NautyGraphs"@
    to generate graphs of small size.  We use @TO "Visualize::Visualize"@ to look at these graphs.
  Example
    needsPackage "Oscillators"
    needsPackage "NautyGraphs"
    needsPackage "Visualize"
    vert4edges4 = generateGraphs(4, 4)
    Gs = vert4edges4/stringToGraph
  Text
    A slightly larger example.
  Example
    vert7edges10 = generateGraphs(7, 10);
    Gs = vert7edges10/stringToGraph
  Text
    Now, for each graph we consider the oscillator dynamical system.
    
    Let's do an example, using a graph with 5 vertices and 7 edges
  Example
    Gstrs = generateGraphs(5,7);
    Gs = Gstrs/stringToGraph
    G = Gs_1
  Pre
    openPort "8083"
    visualize G -- important: click on End session in browser window before continuing
    closePort()
  Example
    R = oscRing(G, CoefficientRing => CC, Reduced => true)
    I = oscSystem(G,R);
    Jac = oscJacobian(G,R)
    realsols = findRealSolutions I
    assert(# realsols == 24)
    stablesols = select(realsols, p -> Stable === identifyStability(Jac,p))
    tally realsols/(p -> identifyStability(Jac, p))
    getAngles(4, stablesols, Radians=>false)
    sols = solveSystem I_*;
    sols = sols/coordinates
    assert(#sols == 36)
    tally sols/(p -> identifyStability(Jac, p))
    netList sols
///

doc ///
  Key
    oscRing
    (oscRing, Graph)
    (oscRing, ZZ)
    [oscRing, Reduced]
    [oscRing, CoefficientRing]
    [oscRing, Symbols]
  Headline
    create a polynomial ring for a given graph or number of oscillators
  Usage
    S = oscRing G
    S = oscRing n
  Inputs
    n:ZZ
      The number of oscillators
    G:Graph
      The number of oscillators is the number of vertices in the Graph
    CoefficientRing => Ring
      the coefficient ring to use, for numerical work, @TO "CC"@ is a good choice
    Symbols => Sequence
      a sequence of two symbols.  The first refers to the cosine of the given angles
        and the second refers to the sine of the given angles
    Reduced => Boolean
      if true, then the angles are reduced to the first angle being 0. That is, the number of oscillators will be one less than the number of vertices of $G$
  Outputs
    :Ring
  Description
    Text
      This function returns a polynomial ring in $2n$ variables
      representing the cosine and the sine of $n$ angles. Inputting a number assumes that the vertices are labeled $0, \ldots, n$.
    Example
      oscRing(3, CoefficientRing => CC)
      oscRing(3, CoefficientRing => CC, Symbols=>{c, s})
    Text
      If one gives a graph with Reduced => true, then the number of angles considered
      is one less than the number of vertices of the graph.
    Example
      G = graph({0,1,2,3}, {{0,1},{1,2},{2,3},{0,3}})
      oscRing G
      oscRing(G, CoefficientRing => CC, Reduced => true)
  SeeAlso
    oscSystem
    oscJacobian
    displayGraph
///

doc ///
  Key
    oscSystem
    (oscSystem, Graph, Ring)
    (oscSystem, Graph)
    [oscSystem, Reduced]
  Headline
    the ideal of the reduced equilibrium points of a dynamical system of oscillators
  Usage
    oscSystem(G,R)
    oscSystem(G)
  Inputs
    G:Graph
      an undirected, connected graph $G$
    R:Ring
      created with @TO oscRing@
    Reduced => Boolean
      if true, then the angles are reduced to the first angle being 0. That is, the number of oscillators will be one less than the number of vertices of $G$
  Outputs
    :Ideal
      in the ring R
  Description
    Text
      $R$ should be a ring created with @TO "oscRing"@.  The dynamical system
      involved is the oscillator system associated to $G$: one angle per vertex.
      If $a_{ij} = 1$ if $(i,j)$ is an edge of the undirected graph $G$, 
      and is zero otherwise, then the system is $d\theta_i/dt = \sum_j a_{ij} \sin(\theta_j - \theta_i)$
      where we consider only reduced equilibrium solutions $\theta_0 = 0$.
      
      This function returns the ideal of equilibrium points, where angles $(0, \theta_1, ..., \theta_{n-1})$
      are represented via cosines and sines of the angles.
    Example
      G = graph({0,1,2,3}, {{0,1},{1,2},{2,3},{0,3}})
      oscRing(G, CoefficientRing => CC)
      R = oo
      I = oscSystem(G,R)
      netList I_*
    Text
      We can find approximations to the 26 complex solutions to this system.
      If the system has positive dimension (not the case here), the idea is that this set of points should
      contain at least one on each component.
    Example
      solveSystem I_*
      #oo
    Text
      We can find approximations to the 6 real solutions to this system.  
    Example
      findRealSolutions I
      #oo
    Text
      The angles of these solutions (in degrees, not radians, and the 3 refers to the
      numbner of oscillators).
    Example
      netList getAngles(3, findRealSolutions I, Radians=>false)
  SeeAlso
      oscRing
      oscJacobian
      findRealSolutions
      getAngles
      solveSystem
///

doc ///
  Key
    oscJacobian
    (oscJacobian,Graph,Ring)
    (oscJacobian, Graph)
    (oscJacobian, Ideal)
    [oscJacobian, Reduced]
  Headline
    create the Jacobian for the oscillator system associated to a graph
  Usage
    oscJacobian(G,R)
    oscJacobian(I)
    oscJacobian(G)
  Inputs
    G:Graph
      an undirected, connected graph $G$ 
    S:Ring
      created with @TO oscRing@
    I:Ideal
      an ideal, intended to be ideal created by oscSystem
    Reduced => Boolean
      if true, then the angles are reduced to the first angle being 0. That is, the number of oscillators will be one less than the number of vertices of $G$
  Outputs
    :Matrix
      the $n \times n$ Jacobian matrix of the system, as a matrix of polynomials
      involving the cosines and sines of angles $\theta_1, \ldots, \theta_{n-1}$, where we
      set $\theta_0 = 0$ if $\texttt{Reduced => true}$
  Description
    Text
      The matrix is a symmetric $n \times n$  matrix (with determinant zero).
    Example
      G = graph({0,1,2,3}, {{0,1},{1,2},{2,3},{0,3}})
      oscRing(G, CoefficientRing => CC)
      S = oo
      I = oscSystem(G,S)
      Jac = oscJacobian(G,S)
      assert(det Jac == 0)
      assert(Jac - transpose Jac == 0)
    Text
      We can find the eigenvalues of the Jacobian at approximate points, and see if they are
      stable (all eigenvalues negative, except for the one required 0), unstable (a positive 
      eigenvalue), or semistable (no positive eigenvalues, up to a certain tolerance).
    Example
      realsols = findRealSolutions I
      jacs = for pt in realsols list sub(Jac, matrix{pt})
      jacs/eigenvalues
      jacs/eigenvalues/identifyStability
  SeeAlso
    oscRing
    oscSystem
    findRealSolutions
    identifyStability
    eigenvalues
///

doc ///
  Key
    findRealSolutions
    (findRealSolutions, Ideal)
    (findRealSolutions, Graph)
  Headline
    find real solutions, at least one per component for well-conditioned systems
  Usage
    findRealSolutions I
    findRealSolutions G
  Inputs
    I:Ideal
      an ideal in a polynomial ring over QQ or RR or CC.
    G:Graph
      an undirected, connected graph $G$
  Outputs
    :List
      of all the real solutions that were found
  Description
    Text
      In this package the main use is to zero in on equilibrium points for oscillator 
      systems associated to graphs.
      
      We use this in the following example.
    Example
      G = graph({0,1,2,3,4}, {{0,1},{1,2},{2,3},{0,3},{0,4}})
      S = oscRing(G, CoefficientRing => QQ, Reduced => true)
      I = oscSystem(G,S)
      dim I
      Jac = oscJacobian(G,S)
      assert(det Jac == 0)
      assert(Jac - transpose Jac == 0)
      realsols = findRealSolutions I      
      netList getAngles(4, realsols, Radians=>false)
      C = decompose I
      for i in C list Jac % i
      M = Jac % C_1
      M1 = matrix{{-1,0,0,0,1},{0,0,0,0,0},{0,0,0,0,0},{0,0,0,0,0},{1,0,0,0,-1}}
      use S
      eigenvalues lift(sub(M - M1, x_3=>1), QQ)
      eigenvalues lift(sub(M, x_3=>1), QQ)
      eigenvalues lift(sub(M, x_3=>1/100000), QQ)
      eigenvalues lift(sub(M, x_3=>100), QQ)
  Caveat
    If the system is positive dimensional, then of course it won't find all roots. There might be
    real roots on a component, but none are found. If a component (even a point) is singular, then
    it might have problems, depending on the situation. In the latter case, there
    is a warning message emitted (about non-regular solutions).
  SeeAlso
    oscRing
    oscSystem
    oscJacobian
    identifyStability
///

doc ///
  Key
    oscQuadrics
    (oscQuadrics, Graph, Ring)
    (oscQuadrics, Graph)
    [oscQuadrics, Reduced]
  Headline
    find the homogeneous quadrics in the homogeneous Kuramoto ideal
  Usage
    oscQuadrics(G,R)
    oscQuadrics(G)
  Inputs
    G:Graph
      an undirected, connected graph $G$ on vertices $0, \ldots, n-1$, where $n$
      is the number of vertices of $G$
    R:Ring
      created with @TO oscRing@
    Reduced => Boolean
      if true, then the angles are reduced to the first angle being 0. That is, the number of oscillators will be one less than the number of vertices of $G$
  Outputs
    :Ideal
      in the ring R
  Description
    Text
      The ideal of quadrics of the oscillator system associated to the graph $G$.
      This is the ideal generated by the quadrics of the system, where the system is
      $d\theta_i/dt = \sum_j a_{ij} \sin(\theta_j - \theta_i)$
      where we consider only reduced equilibrium solutions $\theta_0 = 0$.
    Example
      G = graph({0,1,2,3}, {{0,1},{1,2},{2,3},{0,3}})
      oscRing(G, CoefficientRing => CC)
      S = oo
      I = oscQuadrics(G,S)
      netList I_*
///

doc ///
Key
  standardSols
  (standardSols, Graph, Ring)
  (standardSols, Graph)
  [standardSols, Reduced]
Headline
  find the "standard solutions" for the oscillator system associated to a graph
Usage
  standardSols(G,R)
  standardSols(G)
Inputs
  G:Graph
    an undirected, connected graph $G$
  R:Ring
    created with @TO oscRing@
  Reduced => Boolean
    if true, then the angles are reduced to the first angle being 0. That is, the number of oscillators will be one less than the number of vertices of $G$
Outputs
  :Ideal
    a list of the "standard solutions" that you get where all the angles are the same. This is the same as a certain Segre variety.
Description
  Text
    The oscillator ideal associated to a graph constructed by @TO oscQuadrics@ always contains the "standard solutions" as a minimal prime. These standard solutions are the Segre variety $\mathbb{P}^1\times \mathbb{P}^{n-1}$, where $n$ is the number of vertices of the graph. These are the solutions where all the angles are the same.
  Example
    G = graph({0,1,2,3}, {{0,1},{1,2},{2,3},{0,3}});
    R = oscRing(G);
    I = oscQuadrics(G, R);
    any(decompose I, P -> P == standardSols(G, R))
SeeAlso
  oscRing
  oscSystem
  oscJacobian
///

doc ///
Key 
  vertexSpanningPolynomial
  (vertexSpanningPolynomial, Graph)
  (vertexSpanningPolynomial, Graph, Ring)
Headline
  computes the vertex spanning polynomial
Usage
  vertexSpanningPolynomial(G)
  vertexSpanningPolynomial(G, R)
Inputs
  G:Graph
    an undirected, connected graph $G$
  R:Ring
    created with @TO oscRing@
Outputs
  :PolynomialRing
    the vertex spanning polynomial of the graph $G$ inside $R$.
Description
  Text
    Let $S$ be the set of all spanning trees of the graph $G$. For each spanning tree $T$, let $d_i$ be the degree of $v_i$ in $T$. The vertex spanning polynomial of a graph $G$ is defined as $\sum_{T\in S} \prod_{v_i \in T} x_i^{d_i-1}$. The factorization of this polynomial is related to the number of components of the oscillator ideal of the graph computed via @TO oscQuadrics@.
  Example
    G = graph({0,1,2,3}, {{0,1},{1,2},{2,3},{0,3}});
    vertexSpanningPolynomial G
SeeAlso
  oscQuadrics
///

doc ///
Key
  getAngles
  (getAngles, ZZ, List)
  [getAngles, Radians]
Headline
  Compute angles from a list of solutions
Usage
  getAngles(n, S)
Inputs
  n: ZZ
    An integer representing the number of angles.
  sols: List
    A list of solutions, where each solution is a list of cosine and sine values.
  Radians => Boolean
    An optional boolean flag (default is true). If true, the angles are returned in radians; otherwise, they are returned in degrees.
Outputs
  : List
    A list of angles computed from the given solutions.
Description
  Text
    The function getAngles computes the angles from a list of solutions. Each solution is assumed to be a list of cosine and sine values for the angles. The function returns the angles in radians or degrees based on the Radians option.
  Example
    getAngles(2, {{1, 0, 0, 1}, {0, 1, 1, 0}}, Radians => false)
SeeAlso
  getLinearlyStableSolutions
  findRealSolutions
///

doc ///
Key
  identifyStability
  (identifyStability, Matrix, List)
  (identifyStability, BasicList)
  [identifyStability, Tolerance]
Headline
  Identify the stability of a list of eigenvalues, or of potential solutions to the oscillator system
Usage
  identifyStability(Jac, sols)
  identifyStability(eigenvals)
Inputs
  Jac: Matrix
    A matrix representing the Jacobian of the oscillator system.
  sol: List
    A potential solution to the oscillator system.
  eigenvals: BasicList
    An eigenvalue
  Tolerance => RR
    An optional real number representing the tolerance for the stability check (default is 1e-10).
Outputs
  : BasicList
    A list of stability values for the given solutions or eigenvalues.
Description
  Text
    The function identifyStability computes the stability of a list of solutions or eigenvalues. For solutions, the function computes the eigenvalues of the Jacobian at each solution and determines the stability based on the sign of the real part of the eigenvalues. For eigenvalues, the function determines the stability based on the sign of the real part of the eigenvalues.
  Example
    G = graph({0,1,2,3}, {{0,1},{1,2},{2,3},{0,3}});
    R = oscRing(G, Reduced => true);
    I = oscSystem(G, R);
    Jac = oscJacobian(G, R);
    realsols = findRealSolutions I;
    jacs = for pt in realsols list sub(Jac, matrix{pt});
    eigenvals = jacs/eigenvalues;
    eigenvals / identifyStability
    realsols/(pt -> prepend(identifyStability(Jac, pt), pt))
SeeAlso
  oscJacobian
  findRealSolutions
///

doc ///
Key
  hasNoLeaf
  (hasNoLeaf, Graph)
Headline
  Check if a graph has no leaf vertices
Usage 
  hasNoLeaf(G)  
Inputs
  G: Graph
    An undirected graph
Outputs
  : Boolean
    True if the graph has no leaf vertices, false otherwise
Description
  Text
    The function hasNoLeaf checks if a given graph has no leaf vertices. A leaf vertex is a vertex with degree 1, meaning it is connected to only one other vertex in the graph.
  Example
    G = graph({0,1,2,3}, {{0,1},{1,2},{2,3},{0,3}});
    hasNoLeaf(G)
///

doc ///
Key
  getLinearlyStableSolutions
  (getLinearlyStableSolutions, Graph)
Headline
  Compute linearly stable solutions for the Kuramoto oscillator system associated to a graph
Usage
  getLinearlyStableSolutions(G)
Inputs
  G: Graph
    An undirected, connected graph
Outputs
  : List
    A list of linearly stable solutions for the Kuramoto oscillator system associated to the graph
Description
  Text
    The function getLinearlyStableSolutions computes the linearly stable solutions for the Kuramoto oscillator system associated to a given graph. The Kuramoto oscillator system is a system of coupled phase oscillators, where the dynamics of each oscillator is given by the Kuramoto model. The linear stability of a solution is determined by the eigenvalues of the Jacobian matrix of the system evaluated at the solution.
  Example
    G = graph({0,1,2,3}, {{0,1},{1,2},{2,3},{0,3}});
    getLinearlyStableSolutions(G)
SeeAlso
  findRealSolutions
  identifyStability
///

doc ///
Key
  showExoticSolutions
  (showExoticSolutions, Graph)
Headline
  Display exotic solutions: linearly stable solutions which are not all-in-phase solution
Usage
  showExoticSolutions G
Inputs
  G: Graph
    An undirected, connected graph
Outputs  
  : List
    A list of all of the linearly stable solutions for the Kuramoto oscillator system associated to the graph
Consequences
  Item
    The list of exotic solutions is displayed, together with the angles of the oscillators (where the first angle is always zero, and not displayed)
Description
  Text
    This function first calls @TO getLinearlyStableSolutions@, and then displays any exotic solutions that exist.
    A stable solution is exotic if it is not the all-in-phase solution (all the angles are the same),
    and returns all of the stable solutions found.

    Note that the warning that there are non-regular solutions generally means that it has come across a positive dimensional
    solution set while looking for solutions.  No such solutions can be linearly stable, so the warning is generally not relevant.
  Example
    G = graph {{0,1},{1,2},{2,3},{3,4},{4,0}}
    showExoticSolutions G
  Text
    Note that if there are exotic solutions, all linearly stable solutions are displayed, and if there are no exotic solutions,
    nothing is displayed (other than possibly warnings and timings).
  Example
    G = graph {{0,1},{1,2},{2,3},{3,4},{4,2},{4,0}}
    showExoticSolutions G
SeeAlso
  getLinearlyStableSolutions
  findRealSolutions
  identifyStability
///

doc ///
Key
  allUniquePrincipalMinors
  (allUniquePrincipalMinors, Matrix)
  [allUniquePrincipalMinors, Modulo]
Headline
  Compute all unique principal minors of a given matrix
Usage
  allUniquePrincipalMinors(M)
Inputs
  M: Matrix
    A square matrix
  Modulo => Ideal
    An optional ideal to compute the principal minors modulo the given ideal
Outputs 
  : List
    A list of all unique principal minors of the given matrix
Description
  Text
    The function allUniquePrincipalMinors computes all unique principal minors of a given square matrix. A principal minor of a matrix is the determinant of a submatrix obtained by deleting the same set of rows and columns from the matrix. The function returns a list of all unique principal minors of the given matrix.
  Example
    G = graph({0,1,2,3},{{0,1},{1,2},{2,3},{0,3}})
    S = oscRing(G, CoefficientRing => QQ, Reduced => true)
    I = oscSystem(G,S);
    C = decompose I;
    J = oscJacobian(G,S)
    netList for i in C list allUniquePrincipalMinors(-J, Modulo=>i)
    -- by looking at each one, all points but one are unstable.
SeeAlso
  oscJacobian
  identifyStability
///

doc ///
Key
  isStableSolution
  (isStableSolution, Matrix, List)
Headline
  Check if a given solution is stable for the Kuramoto oscillator system
Usage
  isStableSolution(Jac, sol)
Inputs
  Jac: Matrix
    A matrix representing the Jacobian of the Kuramoto oscillator system
  sol: List
    A potential solution to the Kuramoto oscillator system
Outputs
  : Boolean
    True if the solution is stable, false otherwise
Description
  Text
    The function isStableSolution checks if a given solution is stable for the Kuramoto oscillator system. The stability of a solution is determined by the eigenvalues of the Jacobian matrix of the system evaluated at the solution. If all eigenvalues have negative real parts, the solution is considered stable.
  Example
    G = graph({0,1,2,3}, {{0,1},{1,2},{2,3},{0,3}});
    R = oscRing(G, Reduced => true);
    I = oscSystem(G, R);
    Jac = oscJacobian(G, R);
    realsols = findRealSolutions I;
    select(realsols, S -> isStableSolution(Jac, S))
SeeAlso
  oscJacobian
  findRealSolutions
  identifyStability
///


doc ///
  Key
    "Generation of all SCT (simple, connected, 2-connected) graphs on small numbers of vertices"
  Headline
    generating all SCT graphs on n vertices
  Description
    Text
      Using the NautyGraphs package, we generate the list of
      isomorphism classes of the SCT (simple, connected, 2-connected)
      graphs with a fixed number of vertices.
    Example
      needsPackage "Oscillators"
      needsPackage "NautyGraphs"
      Gstrs = generateGraphs(5, OnlyConnected => true, MinDegree => 2);
      #Gstrs == 11
      Gstrs = generateGraphs(6, OnlyConnected => true, MinDegree => 2);
      #Gstrs == 61
      Gstrs = generateGraphs(7, OnlyConnected => true, MinDegree => 2);
      #Gstrs == 507
      Gstrs = generateGraphs(8, OnlyConnected => true, MinDegree => 2);
      #Gstrs == 7442
      Gstrs = generateGraphs(9, OnlyConnected => true, MinDegree => 2);
      #Gstrs == 197772
    Text
      Here is a simple table with all of these numbers.
    Example
      netList for n from 5 to 9 list {n, #generateGraphs(n, OnlyConnected => true, MinDegree => 2)}
  SeeAlso
///

-- XXX

doc ///
  Key
    "Checking the codimension and irreducible decomposion of the IG ideal"
  Headline
    generating all SCT graphs on n vertices
  Description
    Text
      We first construct the ideal $I_G$ for a specific graph $G$ on 5 vertices.
      We use the 5-cycle as the specific example.
    Example
      needsPackage "Oscillators"
      needsPackage "NautyGraphs"
      Gstrs = generateGraphs(5, OnlyConnected => true, MinDegree => 2);
      Gs = Gstrs/stringToGraph
      G = Gs_3
      R = oscRing(5, Reduced => false);
      IG = oscQuadrics(G, R)
      netList IG_*
      codim IG
    Text
      Each $I_G$ on $n$ vertices has $n-1$ minimal generators.
      This particular $I_G$ has the same codimension $n-1=4$, so is a complete intersection.
      This ideal decomposes as an intersection of 2 prime ideals.
    Example
      comps = decompose IG;
      netList comps_0_*, netList comps_1_*
      comps/codim
      comps/degree
      comps/isPrime
    Text
      Let's see how many graphs are not complete intersections, i.e. have codimension
      $\le n-2$.
    Example
      # select(Gs, G -> (
          IG = oscQuadrics(G, R);
          codim IG <= #vertices G - 2
          ))
    Example
      for G in Gs list (
          IG = oscQuadrics(G, R);
          elapsedTime comps := decompose IG;
          {comps/codim, comps/degree}
          );
      netList oo
    Example
      n = 6
      Gstrs = generateGraphs(n, OnlyConnected => true, MinDegree => 2);
      Gs = Gstrs/stringToGraph;
      R = oscRing(n, Reduced => false);
      # select(Gs, G -> (
          IG = oscQuadrics(G, R);
          codim IG <= #vertices G - 2
          ))
    Example
      allcomps = for G in Gs list (
          IG = oscQuadrics(G, R);
          elapsedTime comps := decompose IG;
          {comps/codim, comps/degree}
          );
      netList ({{"codimensions", "degrees"}} | allcomps)
    Pre
      n = 7
      Gstrs = generateGraphs(n, OnlyConnected => true, MinDegree => 2);
      Gs = Gstrs/stringToGraph;
      R = oscRing(n, Reduced => false);
      # select(Gs, G -> (
          IG = oscQuadrics(G, R);
          elapsedTime codim IG <= #vertices G - 2
          ))
    Text
      The next one takes some time.
    Pre
      n = 8
      Gstrs = generateGraphs(n, OnlyConnected => true, MinDegree => 2);
      Gs = Gstrs/stringToGraph;
      R = oscRing(n, Reduced => false);
      # select(Gs, G -> (
          IG = oscQuadrics(G, R);
          codim IG <= #vertices G - 2
          ))
  
  SeeAlso
///

doc ///
  Key
    "SCT graphs with exotic solutions"
  Headline
    finding graphs of small size with exotic solutions
  Description
    Text
      We first construct the ideal $I_G$ for a specific graph $G$ on 5 vertices.
      We use the 5-cycle as the specific example.
    Example
      debug needsPackage "Oscillators"
      needsPackage "NautyGraphs"
      Gstrs = generateGraphs(5, OnlyConnected => true, MinDegree => 2);
      Gs = Gstrs/stringToGraph
      printingPrecision = 3
      for G in Gs list showExoticSolutions G;
///

doc ///
  Key
    "Example 4.1: unique graph on 8 vertices with exotic solutions and no induced cycle of length at least 5"
  Headline
    example 4.1 in arXiv 2312.16069
  Description
    Text
      This example is a square inside a square, having 8 vertices,
      and exotic solutions. This is the only SCT graph on 8 vertices
      with exotic solutions, not containing an induced $k$-cycle, for $k \ge 5$.
    Example
      needsPackage "Oscillators";
      printingPrecision = 3;
      G = graph{
          {0,4},{1,4},{1,5},
          {3,5},{2,6},{3,6},
          {0,7},{2,7},{4,5},
          {5,6},{6,7},{4,7}}
      stablesols = {{0, 0, -1, .707, -.707, -.707, .707, -1, 1, 0, -.707, -.707, .707, .707},
          {1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0},
          {0, 0, -1, .707, -.707, -.707, .707, 1, -1, 0, .707, .707, -.707, -.707}}
    Text
      Computing the (linearly) stable solutions for K5C5 takes a minute or two:
    Pre
      elapsedTime stablesols = showExoticSolutions G;
  SeeAlso
    "Harrington-Schenck-Stillman"
///

doc ///
  Key
    "Example 4.2: a K5 and pentagon glued along an edge"
  Headline
    example 4.2 in arXiv 2312.16069
  Description
    Text
      The first example is a pentagon.
      The second example is K5 with a 5-cycle glued along an edge.
    Example
      needsPackage "Oscillators";
      printingPrecision = 3;
      Pent = graph{{0,1},{1,2},{2,3},{3,4},{4,0}}
      K5C5 = graph{{0,1},{0,2},{0,3},{0,4},{1,2},{1,3},{1,4},
          {2,3},{2,4},{3,4},{0,5},{5,6},{6,7},{1,7}}
      stablesolsK5C5 = {{1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0},
          {.92, .98, .98, .98, .101, -.98, -.298, -.393, -.201, -.201, -.201, .995, .201, -.954},
          {.92, .98, .98, .98, .101, -.98, -.298, .393, .201, .201, .201, -.995, -.201, .954}}
      elapsedTime stablesolsPent = showExoticSolutions Pent
    Text
      Computing the (linearly) stable solutions for K5C5 takes a minute or two:
    Pre
          elapsedTime stablesolsK5C5 = showExoticSolutions K5C5
  SeeAlso
    "Harrington-Schenck-Stillman"
///

doc ///
  Key
    "Example 4.3: examples of gluing two cycles along an edge"
  Headline
    example 4.3 in arXiv 2312.16069
  Description
    Text
      The following example has two pentagons glued on an edge, and this example
      has 4 exotic solutions, and it is the unique graph on 8 vertices with
      more than 2 exotic solutions.
    Example
      needsPackage "Oscillators";
      printingPrecision = 3;
      PentPent = graph{{0,1},{1,2},{2,3},{3,4},{4,0},{0,5},{5,6},{6,7},{7,1}}
      stablesolsPentPent = {
          {.648, .796, .908, .977, .215, -.908, -.605, .762, .605, .42, .215, -.977, -.42, .796},
          {1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0},
          {.648, .796, .908, .977, .215, -.908, -.605, -.762, -.605, -.42, -.215, .977, .42, -.796},
          {.648, -.605, -.908, .215, .977, .908, .796, .762, .796, -.42, -.977, .215, .42, .605},
          {.648, -.605, -.908, .215, .977, .908, .796, -.762, -.796, .42, .977, -.215, -.42, -.605}}
      stablesolsHexPent
    Text
      The computation of these (linearly) stable solutions takes perhaps a minute:
    Pre
      elapsedTime stablesolsPentPent = showExoticSolutions PentPent
    Text
      The following example has a hexagon and pentago glued identified on a common edge,
      and this example has 9 vertices and 6 exotic solutions.
    Example
      HexPent = graph{{0,1},{1,2},{2,3},{3,4},{4,0},{0,5},{5,6},{6,7},{7,8},{8,1}}
    Text
      The computation of exotic solutions for this example takes several minutes:
    Pre
      elapsedTime stablesolsHexPent = showExoticSolutions HexPent
  SeeAlso
    "Harrington-Schenck-Stillman"
///


doc ///
  Key
    "Example 4.4: The square within a square"
  Headline
    example 4.4 in arXiv 2312.16069
  Description
    Text
      The following is the one graph on 8 vertices with an exotic solution
      where the Jacobian has some off-diagonal extries negative.
    Example
      needsPackage "Oscillators";
      printingPrecision = 3;
      G = graph {{0,1},{1,2},{2,3},{3,4},{4,5},{5,6},{6,0},{0,5},{0,2},{5,7},{2,7}}
      stablesols = {{1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0},
          {.623, -.223, -.901, -.901, -.223, .623, -1, -.782, -.975, -.434, .434, .975, .782, 0},
          {.623, -.223, -.901, -.901, -.223, .623, -1, .782, .975, .434, -.434, -.975, -.782, 0}}
    Pre
      elapsedTime stablesols = showExoticSolutions G
    Text
      The Jacobian at each exotic solution has negative off diagonl entries.
    Example
      Jac = oscJacobian(G, Reduced => true)
      sub(Jac, matrix{stablesols#1})
      sub(Jac, matrix{stablesols#2}) -- this is identical to the previous jacobian
      sub(Jac, matrix{stablesols#0}) -- negative of Laplacian of the graph
  SeeAlso
    "Harrington-Schenck-Stillman"
///


doc ///
  Key
    "Harrington-Schenck-Stillman"
  Headline
    Arxiv 2312.16069 reference
  Description
    Text
      [HSS] @arXiv("2312.16069", "Algebraic examples of homogeneous Kuramoto oscillators")@
            by Heather Harrington, Hal Schenck, Mike Stillman, 2023.
///            

--------------------------------------------------------------------
----- TESTS
--------------------------------------------------------------------
-- Test 0
TEST /// 
  -- A simple example to make sure this is working
-*
  restart
  needsPackage "Oscillators"
*-
  G = graph ({2, 0, 1, 3}, {{0, 2}, {1, 2}, {2, 3}, {0, 3}, {1, 3}})

  S = oscRing(G, Reduced => true)
  assert(numgens S == 6) -- basically: we set theta_0 to 0.

  IG = oscSystem(G,S)

  -- TODO: fix oscRing,oscSystem to handle reduction of any specific vertex.
  -- Ians = ideal(-y_0-y_1-y_3,x_3*y_0-x_0*y_3+y_0,x_3*y_1-x_1*y_3+y_1,-x_3*y_0-x_3*y_1+x_0*y_3+x_1*y_3+y_3,x_0^2+y_0^2-1,x_1^2+y_1^2-1,x_3^2+y_3^2-1)
  -- assert(IG == Ians)
  -- assert(gens IG == gens Ians) -- checking that we did not remove any of the equations.
  -- end of todo section
  
  assert(dim IG == 1)
  
  -- now let's make sure the Jacobian(s) of this system are OK.
  Jac = oscJacobian(G,S)
  assert(det Jac == 0)
  assert(rank Jac == 3)
  assert((numrows Jac, numcols Jac) == (4,4))
///

-- Test 1
TEST ///
  -- The square
-*
  restart
  needsPackage "Oscillators"
*-
  G = graph( {0,1,2,3}, {{0,1}, {1,2}, {2,3}, {0,3}})

  S = oscRing(G, Reduced => true)
  assert(numgens S == 6) -- basically: we set theta_0 to 0.

  IG = oscSystem(G,S)
  Ians = ideal(-y_1-y_3,x_2*y_1-x_1*y_2+y_1,-x_2*y_1+x_1*y_2+x_3*y_2-x_2*y_3,-x_3*y_2+x_2*y_3+y_3,x_1^2+y_1^2-1,x_2^2+y_2^2-1,x_3^2+y_3^2-1)
  assert(IG == Ians)
  assert(gens IG == gens Ians) -- checking that we did not remove any of the equations.
  
  assert(dim IG == 1)
  
  -- now let's make sure the Jacobian(s) of this system are OK.
  Jac = oscJacobian(G,S)
  assert(det Jac == 0)
  assert(rank Jac == 3)
  assert((numrows Jac, numcols Jac) == (4,4))
  
  --numericalIrreducibleDecomposition IG
///

-- Test 2
TEST /// 
-*
  restart
  needsPackage "Oscillators"
*-
  -- The triangle
  G = graph({0,1,2},{{0,1},{1,2},{0,2}})
  R = oscRing(G, CoefficientRing => QQ, Reduced => true)
  I = oscSystem(G,R);
  I = ideal gens gb trim I
      C = decompose I
      standardI = ideal(y_1, y_2, x_1^2-1, x_2^2-1)
      I1 = I : standardI
      I2 = I : I1
      assert(I == intersect(I1, I2))
      assert(I2 == standardI)
      decompose I1
      assert(I == radical I)
      assert(dim I == 0)
      assert(#C == 5) -- 4 standard plus 1 more (which has 2 solutions)
    J = oscJacobian(G,R)
    Jacs = for i in C list J % i
    EVs = for j in Jacs list eigenvalues(lift(j, QQ)) -- self-synch solution is stable, all others are unstable.
    cleanedEVs = EVs/(evs -> evs/(x -> clean(1e-10, x)))
    stable = positions(cleanedEVs, x -> Stable == identifyStability x )
    semistable = positions(cleanedEVs, x -> Semistable == identifyStability x)    
    unstable = positions(cleanedEVs, x -> Unstable == identifyStability x)
    assert(#semistable == 0)
    assert(#unstable == 4)
    assert(#stable == 1)

    unstablesols = select(findRealSolutions I, p -> Unstable === identifyStability(J,p))
    tally ((findRealSolutions I)/(p -> identifyStability(J, p)))
    getAngles(2, unstablesols, Radians=>false)
    
    -- note: the 2 nonstandard solutiona are twisted solutions:
    -- theta_0 = 0, theta_1 = 2 pi/3, theta_2 = 4 pi/3
    -- theta_0 = 0, theta_1 = 4 pi/3, theta_2 = 8 pi/3
    -- upshot: ideal is radical zero-dim, 4 standard solutions, 2 twisted solutions (unstable), SS
///

-- Test 3
TEST ///
  -- analyze stability of all solutions given a graph G
  G = graph({0,1,2,3},{{0,1},{1,2},{2,3},{0,3}})
  S = oscRing(G, CoefficientRing => QQ, Reduced => true)
  I = oscSystem(G,S);
  netList I_*
  dim I
  I == radical I
  C = decompose I;
  assert(#C == 5)
  C = C/trim;
  netList C
  C/dim
  
  J = oscJacobian(G,S)
  netList for i in C list allUniquePrincipalMinors(-J, Modulo=>i)
  -- by looking at each one, all points but one are unstable.
///

--Test 4
TEST ///
  needsPackage "NautyGraphs"
  Gstrs = flatten for i from 4 to 9 list generateGraphs(5,i, OnlyConnected=>true)
  Gs = Gstrs/stringToGraph
  assert(#Gs == 20)
  Gs = select(Gs, G -> all(vertices G, v -> degree(G,v) > 1))
  assert(#Gs == 10)  
  
  -- now let's compute these numerically:
  -- note: this may completely miss the points on
  --  higher dimensional components.  I'm not sure,
  --  but for singular isolated points, I think it
  --  will find all of those, maybe with higher multiplicity.
  n = 5
  realsolsGs = for G in Gs list (
      RC = oscRing(G, CoefficientRing => CC, Reduced => true);
      IC = oscSystem(G,RC);
      JC = oscJacobian(G, RC, Reduced => true);
      elapsedTime realsols = findRealSolutions IC;
      realsols = realsols/(pt -> prepend(identifyStability(JC, pt), pt));
      stablesols = select(realsols, x -> x#0 === Stable);
      (stablesols, realsols)
      )
///

-- Test 5
TEST ///
  needsPackage "Oscillators"
  needsPackage "NautyGraphs"
  n = 5;
  R = oscRing (n, Reduced => true);

  Gstrs = flatten for i from n-1 to binomial(n,2)-1 list generateGraphs(n,i, OnlyConnected=>true);
  #Gstrs
  #Gstrs == 20
  G5s = Gstrs/stringToGraph;
  G5s = select(G5s, hasNoLeaf); #G5s 
  assert(#G5s == 10)

  I0 = oscQuadrics(G5s_0, R)
  -- TODO: the order of generators is different since we are soring vertices.
  --  change the code to allow setting any oscillator to 0.
  -- ans0 = ideal(-x_2*y_4+x_4*y_2+y_2,-y_2-y_3,-x_3*y_1+x_1*y_3+y_3,-x_1*y_4+x_4*y_1+x_3*y_1-x_1*y_3,x_1*y_4+x_2*y_4-x_4*y_1-x_4*y_2)
  -- assert(gens I0 ==  gens ans0)
  
  I0 = oscQuadrics(G5s_4, R)
  Seg = standardSols(G5s_4, R)
  I1 = I0 : Seg
  trim(I1 + Seg)
  (codim oo, degree oo)
  
  for G in G5s list G => getLinearlyStableSolutions G
  pt = first getLinearlyStableSolutions G5s_0
  pt1 = {1.0} | pt_{0..3} | {0.0} | pt_{4..7}
  RC = oscRing(n);
  I = oscQuadrics(G5s_0, RC)
  sub(I, matrix {pt1})
  comps = decompose I
  netList comps
  comps/(i -> sub(i, matrix{pt1}))  
  dim comps_1
  oscSystem(G5s_0, R)     
///

-- Test 6
TEST ///
  --Let's do all connected graphs with 4 vertices, which do not have a vertex with degree 1
    needsPackage "Oscillators"
    needsPackage "NautyGraphs"
    needsPackage "Visualize"

    n = 4
    -- There are 6 connected graphs:
    Gstrs = flatten for i from 3 to 6 list generateGraphs(n,i, OnlyConnected=>true)
    Gs = Gstrs/stringToGraph
    assert(#Gs == 6)
    -- the first 2 are trees:
    assert(Gs/isTree == splice{2:true, 4:false})
    Gs = select(Gs, G -> all(vertices G, i -> degree(G,i) > 1))
    assert(#Gs == 3)
    -- there are (at least) two ways to view graphs in Macaulay2.  The first 
    -- just pops up a jpeg picture using graphviz (which you must have
    -- installed on your system):
    -- displayGraph Gs_0
    -- Gs/displayGraph

    -- The next lines are for viewing graphs in your browser.
    -- This generally gives a nicer picture than graphviz, and you can change the look,
    -- and output tikz code too.  However, you need to end the session in the browser
    -- in order to move on to the next graph.
    -- SS: self synchro (only one stable real solution)
    -- POS: has positive dimensional components
    -- NONRAD: is not reduced
    -- NONREG: some solutions are not regular (from homotopy continuation)
    --openPort "8080"
    --visualize Gs_0 -- square NONREG SS POS
    --visualize Gs_1 -- square with one diagonal NONREG SS NONRAD POS
    --visualize Gs_2 -- complete graph NONREG SS NONRAD POS
    --closePort()

    realsolsGs = for G in Gs list (
        RC = oscRing(G, CoefficientRing => CC, Reduced => true);
        IC = oscSystem(G,RC);
        JC = oscJacobian(G, RC);
        elapsedTime realsols = findRealSolutions(IC);
        realsols = realsols/(pt -> prepend(identifyStability(JC, pt), pt));
        stablesols = select(realsols, x -> x#0 === Stable);
        (stablesols, realsols)
        )

    netList realsolsGs_0_1 -- one stable, 4 semistable (Jacobian == 0 at these), all rest unstable
    netList realsolsGs_1_1 -- 6 standard solutions, 6 others.
    netList realsolsGs_2_1 -- only standard solutions, yet some of the unstable ones must be singular
                             -- since some solutions appear more than once.


    realsolsGsQQ = for G in Gs list (
        R = oscRing(G, CoefficientRing => QQ, Reduced => true);
        I = oscSystem(G,R);
        J = oscJacobian(G,R);
        C = decompose I;
        C = select(C, i -> dim i == 0);
        C = C/(i -> sub(i, R));
        realsols = C/findRealSolutions//flatten;
        stablesols = select(realsols, p -> isStableSolution(J, p));
        {stablesols, realsols}
        )

    netList realsolsGsQQ_0_1 -- this one has 2 isolated solutions, both with sin theta_i = 0. (all i)
    netList realsolsGsQQ_1_1 -- this one has 4 isolated solutions, all with sin theta_i = 0
    netList realsolsGsQQ_2_1 -- this one has 5 isolated solutions, all with sin theta_i = 0

    Is = for G in Gs list (
        I = oscSystem(G,R);
        J = oscJacobian(G,R);
        C = decompose I;
        (I, C, J)
        )

    Is/first/dim
    Cs = Is/first/primaryDecomposition
    select(Cs_0, i -> dim i == 0 and i == radical i)
    select(Cs_0, i -> dim i == 0 and i != radical i)

    select(Cs_1, i -> dim i == 0 and i == radical i)
    select(Cs_1, i -> dim i == 0 and i != radical i)

    select(Cs_2, i -> dim i == 0 and i == radical i)
    select(Cs_2, i -> dim i == 0 and i != radical i)

    Is/(x -> x#1)/length

    -- let's consider the higher dimensional components, and radical-ness of ideals
    for i in Is/first list  radical i == i
    Is/first/dim -- {0,0,0,1,1,1}
    -- Notes:
    -- (1) the first 3 graphs have edges sticking out.
    -- (2) the first 3 graphs have radical ideals, of dim 0.
    -- We now describe the features of each example.
    --
    ---------------------
    -- Graph Gs_0
    -- square
    G = graph ({0, 1, 2, 3}, {{0, 1}, {1,2}, {2, 3}, {0,3}})
    R = oscRing(G, CoefficientRing => QQ, Reduced => true)
    I = oscSystem(G,R)
    C = decompose I
    trim first Is_0 -- 8 solutions: all sin=0, cos=+-1.
    assert(I == radical I) -- true
    C = decompose I
    J = oscJacobian(G,R)
    Jacs = for i in C list J % i
    --for j in Jacs list eigenvalues(lift(j, QQ))
      -- upshot: this is a tree, ideal is a reduced set of the 8 "standard" points.
      --   self-synch pt: yes
      --   other 7 are unstable.
    ---------------------
    -- Graph Gs_1
    -- square with one diagonal
    -- sort vertices Gs_1, (edges Gs_1)/toList/sort//sort
    G = graph ({0, 1, 2, 3}, {{0, 2}, {0, 3}, {1, 2}, {1, 3}, {2, 3}})
    I = oscSystem(G,R);
    C = decompose I
    PD = primaryDecomposition I
    gbI = ideal gens gb trim I
    J = oscJacobian(G,R)
    Jacs = for i in C list J % i
    --for j in Jacs list eigenvalues(lift(j, QQ))
      -- upshot: this is a tree, ideal is a reduced set of the 8 "standard" points.
      --   self-synch pt: yes
      --   other 7 are unstable.
    ---------------------
    -- Graph Gs_2
    -- complete graph on 4 vertices
    -- sort vertices Gs_2, (edges Gs_2)/toList/sort//sort
    G = graph ({0, 1, 2, 3}, {{0, 1}, {0, 2}, {0, 3}, {1, 2}, {1, 3}, {2, 3}})
    I = oscSystem(G,R);
    C = decompose I
    C/dim
    #C
    PD = primaryDecomposition I
    #PD
    PD/dim
    PD/(i -> i == radical i)
    J = oscJacobian(G,R)
    assert(#C == 8) -- 3 of dim 1, 5 standard points
    for i in C list allUniquePrincipalMinors(-J, Modulo => i)
    C0 = select(C, i -> dim i == 0)
    C1 = select(C, i -> dim i >  0)
    Jacs0 = for i in C0 list J % i
    for j in Jacs0 list eigenvalues(lift(j, QQ)) -- one stable, the other 4 are unstable.
    trim(C1_0 + C1_1) -- a standard point
    trim(C1_0 + C1_2) -- a different standard point
    trim(C1_1 + C1_2) -- a different standard point
    assert(1 == trim(C1_0 + C1_1 + C1_2)) -- don't intersect
    -- geometry: there are 8 components, all reduced.
    --  have 3 curve solutions C0, C1, C2: each consisting solely of unstable points
    --  have 5 standard isolated solutions, one of which is singular.
    --  4 are unstable, 1 is stable.
    -- the pairwise intersection of 2 of the curves is a single (unstable standard point) (all different).
    -- the three curves do not have a common intersection.
    -- there are 3 embedded points (the intersection points of the curves), all standard.
    -- all 8 standard points occur as associated primes.
///

-- Test 7
TEST ///
-- Test: oscJacobian and reduced version return the same eigenvalues, except for
--  one extra eigenvalue of 0.0 for the non-reduced form.
-- XXX
  restart
    needsPackage "Oscillators"
    needsPackage "NautyGraphs"

    n = 4
    -- There are 6 connected graphs:
    Gstrs = flatten for i from 3 to 6 list generateGraphs(n,i, OnlyConnected=>true)
    Gs = Gstrs/stringToGraph

    G = Gs_4
    RC = oscRing(3, {}, CoefficientRing => CC)
    J1 = oscJacobian(G,RC,Reduced=>false)
    J2 = oscJacobian(G,RC)

    PC = oscSystem(G,RC);
    IC = PC + trig RC;
    elapsedTime realsols = findRealSolutions IC;
    netList realsols    
    evs = for p in realsols list map(CC, RC, p)
    evsJ1 = for phi in evs list eigenvalues phi J1 -- I think J1 is not correct..
    evsJ2 = for phi in evs list eigenvalues phi J2
///

--Test 8
TEST ///
  --Let's do all connected graphs with 5 vertices -- YYY
  restart
    needsPackage "Oscillators"
    needsPackage "NautyGraphs"
    needsPackage "Visualize"

    n = 5
    Gstrs = flatten for i from 4 to 10 list generateGraphs(n,i, OnlyConnected=>true)
    Gs = Gstrs/stringToGraph
    assert(#Gs == 21)
    -- openPort "8080"
    -- visualize Gs_3
    -- closePort()

    RC = oscRing(n-1,{}, CoefficientRing => CC)
    R = oscRing(n-1,{}, CoefficientRing => QQ)
    realsolsGs = for G in Gs list (
        PC = oscSystem(G,RC);
        JC = oscJacobian(G, RC);
        IC = PC + trig RC;
        elapsedTime realsols = findRealSolutions IC;
        stablesols = select(realsols, p -> isStableSolution(JC,p));
        (stablesols, realsols)
        )
    netList realsolsGs
    realsolsGs/(x -> (#x#0, #x#1))//netList 

    realsolsGsQQ = for G in drop(Gs,-1) list (
        << "doing " << G << endl;
        P = oscSystem(G,R);
        JC = oscJacobian(G, RC);
        J = oscJacobian(G,R);
        I = P + trig R;
        C = elapsedTime decompose I;
        C = select(C, i -> dim i == 0);
        C = C/(i -> sub(i, RC));
        elapsedTime realsols = C/findRealSolutions//flatten;
        stablesols = select(realsols, p -> isStableSolution(JC, p));
        << "stablesols = " << stablesols << endl << " #real sols = " << #realsols << endl;
        {stablesols, realsols}
        )
    netList realsolsGsQQ
    realsolsGsQQ/(x -> (#x#0, #x#1))//netList 

    -- the only one with more than one stable (isolated) solution is the pentagon ring.
    G = Gs_7
    -- openPort "8081"
    -- visualize G
    -- closePort()
    
    dims = for G in drop(Gs,-1) list (
        << "doing " << G << endl;
        P = oscSystem(G,R);
        I = P + trig R;
        C = elapsedTime decompose I;
        G => tally (C/dim)
        )
    positions(dims, x -> x#1#?1 or x#1#?2)
    -- openPort "8081"
    -- visualize dims#4#0
    -- visualize dims#8#0
    -- visualize dims#9#0
    -- visualize dims#12#0
    -- visualize dims#13#0
    -- visualize dims#15#0
    -- visualize dims#16#0
    -- visualize dims#17#0
    -- visualize dims#19#0
    
    -- visualize dims#5#0
    -- visualize dims#6#0    
    -- visualize dims#7#0    
    -- visualize dims#10#0    
    -- visualize dims#11#0    
    -- visualize dims#14#0    
    -- closePort()
    
///

-- Test 9
TEST ///
    needsPackage "NautyGraphs"
    needsPackage "Visualize"

    n = 6
    Gstrs = flatten for i from n-1 to binomial(n,2)-1 list generateGraphs(n,i, OnlyConnected=>true)
    Gcomplete = stringToGraph first generateGraphs(n,binomial(n,2), OnlyConnected=>true)
    assert(#Gstrs == 111)
    Gs = Gstrs/stringToGraph;

    getSols = (G) -> (
        << "---- doing graph " << G << endl;
        n := # vertices G;
        RC = oscRing(n, CoefficientRing => CC, Reduced => true);
        PC = oscSystem(G,RC);
        JC = oscJacobian(G, RC);
        IC = PC + trig RC;
        elapsedTime realsols = findRealSolutions IC;
        stablesols = select(realsols, p -> isStableSolution(JC,p));
        << netList stablesols << endl;
        (stablesols, realsols)
        )
    getSols Gs_0 -- one sol

    G = Gs_21
    R = oscRing(n, CoefficientRing => QQ, Reduced => true)
    P = oscSystem(G,R);
    J = oscJacobian(G,R);
    I = P + trig R;
    dim I
    degree I
    C0 = select(decompose I, i -> dim i == 0)
    C = primaryDecomposition I
    for i in C0 list lift(J % i, QQ)
    for i in C0 list lift((vars ring i)%i, QQ)
    Isat = saturate(I, product(5, i -> y_(i+1)))
    I0 = I : Isat
    I == intersect(I0, Isat)
///

--Test 10
TEST ///
-- MES XXX
    needsPackage "NautyGraphs"
    needsPackage "Visualize"
    n = 7
    Gstrs = flatten for i from n-1 to binomial(n,2)-1 list generateGraphs(n,i, OnlyConnected=>true)
    Gs = Gstrs/stringToGraph;
    #Gs
    assert(#Gs == 852)
    positions(Gs, isTree) -- the first 11 are trees, that is it...

    getSols = (G) -> (
        << "---- doing graph " << G << endl;
        n := # vertices G;
        RC = oscRing(n, CoefficientRing => CC, Reduced => true);
        PC = oscSystem(G,RC);
        JC = oscJacobian(G, RC);
        IC = PC + trig RC;
        elapsedTime realsols = findRealSolutions IC;
        stablesols = select(realsols, p -> isStableSolution(JC,p));
        << netList stablesols << endl;
        (stablesols, realsols)
      )

    -- example: Gs_11 (one triangle, with edges sticking out)
    G = Gs_11
    R = oscRing(n, CoefficientRing => QQ, Reduced => true)
    P = oscSystem(G,R);
    J = oscJacobian(G,R);
    I = P + trig R;
    dim I
    C = decompose I
    for i in C list ((vars R) % i)
    assert(I == intersect C) -- true, so reduced, zero dimensional
    realroots = flatten for i in C list findRealSolutions i -- 96 real points.  Interesting, since degree is 96...
    RC = oscRing(n, CoefficientRing => CC, Reduced => true)
    JC = oscJacobian(G,RC);
    realroots/(p -> isStableSolution(JC,p))
    -- upshot: 96 roots, all real, exactly one is stable.
    realroots/(p -> (map(CC,RC,p)) JC)
    oo/eigenvalues

    -- example: Gs_500 (planar symmetric triangulation of a triangle)
    G = Gs_500
    R = oscRing(n, CoefficientRing => ZZ/32003, Reduced => true)
    P = oscSystem(G,R);
    J = oscJacobian(G,R);
    I = P + trig R; -- appears to have dim 0, degree 232 (these are OK in char 32003).
///

end------------------------------------

restart
uninstallPackage "Oscillators";
restart
installPackage "Oscillators"
check Oscillators
debug needsPackage "Oscillators";


